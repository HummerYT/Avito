// Code generated by MockGen. DO NOT EDIT.
// Source: contract.go

// Package mocks is a generated GoMock package.
package mocks

import (
	models "AvitoTask/internal/models"
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	pgx "github.com/jackc/pgx/v5"
)

// Mockuser is a mock of user interface.
type Mockuser struct {
	ctrl     *gomock.Controller
	recorder *MockuserMockRecorder
}

// MockuserMockRecorder is the mock recorder for Mockuser.
type MockuserMockRecorder struct {
	mock *Mockuser
}

// NewMockuser creates a new mock instance.
func NewMockuser(ctrl *gomock.Controller) *Mockuser {
	mock := &Mockuser{ctrl: ctrl}
	mock.recorder = &MockuserMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockuser) EXPECT() *MockuserMockRecorder {
	return m.recorder
}

// BeginTx mocks base method.
func (m *Mockuser) BeginTx(ctx context.Context) (pgx.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTx", ctx)
	ret0, _ := ret[0].(pgx.Tx)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginTx indicates an expected call of BeginTx.
func (mr *MockuserMockRecorder) BeginTx(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTx", reflect.TypeOf((*Mockuser)(nil).BeginTx), ctx)
}

// GetUserById mocks base method.
func (m *Mockuser) GetUserById(ctx context.Context, tx pgx.Tx, userID string) (models.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUserById", ctx, tx, userID)
	ret0, _ := ret[0].(models.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUserById indicates an expected call of GetUserById.
func (mr *MockuserMockRecorder) GetUserById(ctx, tx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserById", reflect.TypeOf((*Mockuser)(nil).GetUserById), ctx, tx, userID)
}

// GetUserByLoginWithTx mocks base method.
func (m *Mockuser) GetUserByLoginWithTx(ctx context.Context, tx pgx.Tx, login string) (models.User, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUserByLoginWithTx", ctx, tx, login)
	ret0, _ := ret[0].(models.User)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUserByLoginWithTx indicates an expected call of GetUserByLoginWithTx.
func (mr *MockuserMockRecorder) GetUserByLoginWithTx(ctx, tx, login interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserByLoginWithTx", reflect.TypeOf((*Mockuser)(nil).GetUserByLoginWithTx), ctx, tx, login)
}

// GetUserCoins mocks base method.
func (m *Mockuser) GetUserCoins(ctx context.Context, tx pgx.Tx, userID string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUserCoins", ctx, tx, userID)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUserCoins indicates an expected call of GetUserCoins.
func (mr *MockuserMockRecorder) GetUserCoins(ctx, tx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserCoins", reflect.TypeOf((*Mockuser)(nil).GetUserCoins), ctx, tx, userID)
}

// IsUserExists mocks base method.
func (m *Mockuser) IsUserExists(ctx context.Context, user models.User) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsUserExists", ctx, user)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsUserExists indicates an expected call of IsUserExists.
func (mr *MockuserMockRecorder) IsUserExists(ctx, user interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUserExists", reflect.TypeOf((*Mockuser)(nil).IsUserExists), ctx, user)
}

// UpdateUserCoins mocks base method.
func (m *Mockuser) UpdateUserCoins(ctx context.Context, tx pgx.Tx, userID string, newCoins int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateUserCoins", ctx, tx, userID, newCoins)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateUserCoins indicates an expected call of UpdateUserCoins.
func (mr *MockuserMockRecorder) UpdateUserCoins(ctx, tx, userID, newCoins interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateUserCoins", reflect.TypeOf((*Mockuser)(nil).UpdateUserCoins), ctx, tx, userID, newCoins)
}

// Mockinventory is a mock of inventory interface.
type Mockinventory struct {
	ctrl     *gomock.Controller
	recorder *MockinventoryMockRecorder
}

// MockinventoryMockRecorder is the mock recorder for Mockinventory.
type MockinventoryMockRecorder struct {
	mock *Mockinventory
}

// NewMockinventory creates a new mock instance.
func NewMockinventory(ctrl *gomock.Controller) *Mockinventory {
	mock := &Mockinventory{ctrl: ctrl}
	mock.recorder = &MockinventoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockinventory) EXPECT() *MockinventoryMockRecorder {
	return m.recorder
}

// GetInventoryItem mocks base method.
func (m *Mockinventory) GetInventoryItem(ctx context.Context, tx pgx.Tx, userID, itemType string) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetInventoryItem", ctx, tx, userID, itemType)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetInventoryItem indicates an expected call of GetInventoryItem.
func (mr *MockinventoryMockRecorder) GetInventoryItem(ctx, tx, userID, itemType interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInventoryItem", reflect.TypeOf((*Mockinventory)(nil).GetInventoryItem), ctx, tx, userID, itemType)
}

// InsertInventoryItem mocks base method.
func (m *Mockinventory) InsertInventoryItem(ctx context.Context, tx pgx.Tx, id, userID, itemType string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertInventoryItem", ctx, tx, id, userID, itemType)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertInventoryItem indicates an expected call of InsertInventoryItem.
func (mr *MockinventoryMockRecorder) InsertInventoryItem(ctx, tx, id, userID, itemType interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertInventoryItem", reflect.TypeOf((*Mockinventory)(nil).InsertInventoryItem), ctx, tx, id, userID, itemType)
}

// UpdateInventoryItem mocks base method.
func (m *Mockinventory) UpdateInventoryItem(ctx context.Context, tx pgx.Tx, userID, itemType string, newQuantity int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateInventoryItem", ctx, tx, userID, itemType, newQuantity)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateInventoryItem indicates an expected call of UpdateInventoryItem.
func (mr *MockinventoryMockRecorder) UpdateInventoryItem(ctx, tx, userID, itemType, newQuantity interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateInventoryItem", reflect.TypeOf((*Mockinventory)(nil).UpdateInventoryItem), ctx, tx, userID, itemType, newQuantity)
}
